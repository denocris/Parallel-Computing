<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
  <title>BlueWaters/TeraGrid Petascale Summer School - Jacobi Iteration
Algorithm Background</title>
</head>
<body>
<h2 style="text-align: left;">Background</h2>
The algorithm used in this program solves Laplace&#8217;s equation on an
evenly spaced grid through the use of a simple Jacobi iteration
technique.&nbsp;&nbsp; The equation is a partial differential equation
named after Pierre-Simon Laplace and are important in many fields of
science: namely the fields of electromagnetism, astronomy and fluid
dynamics.&nbsp; The physical interpretation of the equations is they
describe the behavior of potentials.&nbsp; <br>
<br>
The equation has the form:<br>
<br>
<img style="width: 102px; height: 48px;" alt="Equation 1"
 src="jacobiEq1.jpg"><br>
<br>
A practical solution to this equation is the use of a Jacobi iteration
that employs numerical second derivatives.&nbsp; Lets assume that we
would like to know the state of heat flow across a metal surface where
the source is coming from one of the corners of the square
surface.&nbsp; <br>
<br>
To tackle this, we would set up a two dimensional grid to represent the
surface, and we will divide it evenly into square regions.&nbsp; We can
simulate the heat source by defining the boundary conditions along the
sides of the grid.&nbsp; In this case, we will be setting the bottom
left corner to 100.0 and with an increasing gradient toward the other
corners until it is zero.&nbsp; Once these conditions are set, the
algorithm will use numerical solutions to the second derivatives in
each direction to update the current matrix elements. And although we
won&#8217;t check for convergence, the flow of the surface will eventually
hit a steady-state.<br>
<br>

<h3>The Algorithm</h3>
Following is a high-level description of the algorithm you will be
implementing. Figure 1 shows a diagram of the grid that will result
from the algorithm.&nbsp; <br>
<ol>
  <li>Allocate and specify a 2D array defining an evenly spaced grid of
square dimension.&nbsp; You will need to leave space for the
boundaries, as they do not belong to the main grid (i.e. a 1024 x 1024
matrix would need to be allocated as 1026x1026 to leave room for the
borders.<br>
    <br>
  </li>
  <li>Setup the initial constant boundary conditions.&nbsp; The value
at the lower left hand corner of the of the grid will be fixed at
100.00, and the value ascending and to the right will be set to a
linear gradient reaching zero at the opposite corners (see Figure
1.).&nbsp; The rest of the borders will be fixed at zero.&nbsp; Please
note, these boundaries will remain constant throughout the simulation.<br>
    <br>
  </li>
  <li>Setup the initial condition of the inner grid elements as 0.5.<br>
    <br>
  </li>
  <li>Begin and continue for a fixed number of cycles the iterative
process.&nbsp; At each iteration, the value of each inner matrix
element needs to be recomputed from elements of the current
iteration.&nbsp; The updating formula, based on numerical computation
of second derivatives, is:<br>
    <br>
    <img style="width: 284px; height: 28px;" alt="Equation 2"
 src="eqn.PNG"><br>
    <br>
  </li>
  <li>After updating, copy the new matrix into the old's memory and
continue iterations until completion.</li>
</ol>
<img style="width: 630px; height: 472px;" alt="Figure1"
 src="jacobiFigure1.jpg"><br>
<br>
</body>
</html>
